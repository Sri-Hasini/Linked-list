# 141. Linked List Cycle
- [Problem link from Leetcode](https://leetcode.com/problems/linked-list-cycle/)
- [Explanation link from GfG](https://www.geeksforgeeks.org/how-does-floyds-slow-and-fast-pointers-approach-work/)
- [Problem link from Gfg](https://www.geeksforgeeks.org/problems/detect-loop-in-linked-list/1?itm_source=geeksforgeeks&itm_medium=article&itm_campaign=practice_card)
## Question
## Medium &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Accuracy(51 %)
Given head, the head of a linked list, determine if the linked list has a cycle in it.
There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. 
Internally, pos is used to denote the index of the node that tail's next pointer is connected to. 
Note that pos is not passed as a parameter.
Return true if there is a cycle in the linked list. Otherwise, return false.

## Approach 

## Code in cpp
```cpp
 /**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    bool hasCycle(ListNode *head) {
        ListNode * slow = head;//kept slow pointer as head
        ListNode * fast = head;//kept fast pointer as head
        while (fast != NULL && fast->next != NULL) {//we run this until our fast and fast->next not equals nullptr
            slow = slow->next;//takes one step
            fast = fast->next->next;//takes two steps
            if (slow == fast) {//if they are equal it means a cycle exits
                return true;//so return true
            }
        }
        return false;//or else return false;
    }
};
```
