# Performing operations individually
## 1. Inserting a node at the end of the linked list
```cpp
//there is no need to pass the head actually
//we can directly write it as a void functiona and only pass value 
//as a parameter
//like : void insert(int val)
 Node * insert_end(Node * head, int val) {
    Node * temp = new Node(val);
    if (head == nullptr) {
        head = tail = temp;
    }
    else {
        tail->next = temp;
        tail = temp;
    }
    return head;
}
```
## 2. Inserting a node at the beginning of the linked list
```cpp

```

## 3. Inserting a node at a given position 
```cpp

```

## 4. Deleting a node from the beginning
```cpp
//Delete a node from the beginning
Node * delete_head(Node * head) {
    if (head == NULL) return head;//if empty return head directly
    if (head == tail) {
        free(tail);//if have only one element, we can free head or tail
        head = tail = NULL;//assign it to null
        return head;//return head
    }
    Node *temp = head;//otherwise create a temporary node
    head = head->next;//keep the head as the 1st element (inorder to remove connection fromt that previous head node)
    delete temp;//delete the temporary node(which contains head)
    return head;//return head
}
```

## 5. Deleting a node from the end
```cpp
//delete a node from the end
Node * delete_end(Node * head) {
    if (head == NULL) return head;//if LL is empty, can return head directly
    else if (head->next == NULL) {//if has only one node, or we can also check for (head == tail)
        free(tail);//we can free head or tail 
        head = tail = NULL;//keep both head and tail to null
        return head;//return the head
    }
    else {
        Node *temp = head;//or else we can create a temporary node and assign head to it
        while (temp->next->next) {//iterate until the 2nd last element
            temp = temp->next;
        }
        free(temp->next);//free the last node 
        temp->next = NULL;//so, the last node is now the previous node (2nd last will be last now), point it's next to null
    }
    return head;//return head
}
```

## 6. Deleting a node from any position
```cpp
//delete a node from the kth position
Node * delete_position(Node * head, int k) {
    if (head == NULL) return head;// if it is null, it represents that LL is empty and we can directly return it
    if (k == 1) {//it means we need to remove the head 
        Node * temp = head;
        head = head->next;
        delete temp;
        return head;
    }
    int cnt = 0;//for counting the positions
    Node * temp = head, * prev = nullptr;//temporary node for traversing and previous node for keeping track of the previous node
    while (temp) {
        cnt++;//increment cnt value for every iteration denoting position
        if (cnt == k) {//if it is equal to the given k value
            prev->next = prev->next->next;//we keep previous node's next as current node's next (nothing but (prev->next) denotes current and ->next denotes its next)
            free(temp);//free the temp which is the current kth node
            break;//we can stop the loop , so break it
        }
        prev = temp;//we always keep track of the previous node here
        temp = temp->next;//this represents the current node
    }
    return head;
}
```
## 7.Display
```cpp
//display the elements in the linked list
void display(Node * head) {
    Node * temp = head;//create a temporary node assign the head
    while (temp) {//iterate until it becomes null
        cout << temp->data << " ";//print the data
        temp = temp->next;
    }
}
```
